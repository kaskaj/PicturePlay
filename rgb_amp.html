<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RGB Synth UI</title>
    <style>
        body {
            margin: 0;
            font-family: sans-serif;
            background: white;
            color: black;
        }

        #topbar {
            background: black;
            padding: 10px;
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            color: white;
        }

        .control {
            display: flex;
            align-items: center;
            gap: 6px;
            color: white;
            font-size: 14px;
        }

        .control label {
            white-space: nowrap;
        }

        .control span {
            min-width: 48px;
            text-align: right;
        }

        .hidden {
            display: none !important;
        }

        .knob-control {
            flex-direction: column;
            align-items: center;
            gap: 6px;
            min-width: 64px;
        }

        .knob-control label {
            font-size: 12px;
            letter-spacing: 0.02em;
            text-transform: uppercase;
        }

        .knob-control span {
            min-width: auto;
            text-align: center;
            font-variant-numeric: tabular-nums;
            font-size: 12px;
        }

        .select-control {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: flex-start;
            min-width: 120px;
        }

        .select-control label {
            font-size: 12px;
            letter-spacing: 0.02em;
            text-transform: uppercase;
            color: white;
        }

        .select-control select {
            background: #222;
            color: white;
            border: 1px solid #555;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .tonal-notes {
            display: flex;
            flex-direction: column;
            gap: 6px;
            background: rgba(0, 0, 0, 0.35);
            padding: 8px 10px;
            border-radius: 6px;
            color: white;
            width: 100%;
        }

        .tonal-notes__label {
            font-size: 12px;
            letter-spacing: 0.02em;
            text-transform: uppercase;
        }

        .tonal-notes__grid {
            display: grid;
            grid-template-columns: repeat(6, minmax(0, 1fr));
            gap: 4px 12px;
            font-size: 12px;
        }

        .tonal-notes__grid label {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
        }

        .tonal-notes__grid input {
            accent-color: #888;
        }

        .knob-wrapper {
            position: relative;
            width: 40px;
            height: 40px;
        }

        .knob-input {
            position: absolute;
            inset: 0;
            margin: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
            touch-action: none;
            user-select: none;
        }

        .knob-visual {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.8);
            background: conic-gradient(from -135deg, #cfcfcf 0deg, #cfcfcf var(--fill, 0deg), #ffffff var(--fill, 0deg), #ffffff 360deg);
            box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.12), 0 2px 6px rgba(0, 0, 0, 0.35);
            pointer-events: none;
        }

        input[type="range"] {
            accent-color: #888;
        }

        button {
            background: #444;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
        }

        button:hover {
            background: #555;
        }

        #content {
            display: flex;
            gap: 0;
        }

        #canvasWrapper {
            position: relative;
            display: inline-block;
        }

        .canvas-col {
            display: flex;
            flex-direction: column;
        }

        #highlightCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 2;
        }

        canvas {
            display: block;
            margin: 0;
            padding: 0;
            image-rendering: pixelated; /* makes zoomed pixels crisp */
            border: none;
        }
    </style>
</head>
<body>
<div id="topbar">
    <input type="file" id="fileInput" accept="image/*" style="display:none;">
    <button id="uploadBtn">Upload</button>
    <button id="playBtn">Play</button>
    <button id="stopBtn">Stop</button>

    <div class="control knob-control">
        <label for="detuneControl">Detune</label>
        <div class="knob-wrapper">
            <input type="range" id="detuneControl" min="0" max="200" value="10" class="knob-input">
            <div class="knob-visual"></div>
        </div>
        <span id="detuneValue">10%</span>
    </div>

    <div class="control knob-control">
        <label for="stereoControl">Stereo</label>
        <div class="knob-wrapper">
            <input type="range" id="stereoControl" min="0" max="100" value="50" class="knob-input">
            <div class="knob-visual"></div>
        </div>
        <span id="stereoValue">50%</span>
    </div>

    <div class="control knob-control">
        <label for="speedControl">Speed</label>
        <div class="knob-wrapper">
            <input type="range" id="speedControl" min="0.02" max="0.5" step="0.01" value="0.1" class="knob-input">
            <div class="knob-visual"></div>
        </div>
        <span id="speedValue">0.10s/col</span>
    </div>

    <div class="control knob-control">
        <label for="contrastControl">Contrast</label>
        <div class="knob-wrapper">
            <input type="range" id="contrastControl" min="0" max="100" value="0" class="knob-input">
            <div class="knob-visual"></div>
        </div>
        <span id="contrastValue">0%</span>
    </div>

    <div class="control knob-control" id="baseFreqWrapper">
        <label for="baseFreqControl">Base Freq</label>
        <div class="knob-wrapper">
            <input type="range" id="baseFreqControl" min="20" max="1000" value="100" class="knob-input">
            <div class="knob-visual"></div>
        </div>
        <span id="baseFreqValue">100 Hz</span>
    </div>

    <div class="control select-control hidden" id="octaveWrapper">
        <label for="octaveSelect">Octave</label>
        <select id="octaveSelect">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3" selected>3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
        </select>
    </div>

    <div class="control knob-control">
        <label for="attackControl">Attack</label>
        <div class="knob-wrapper">
            <input type="range" id="attackControl" min="0" max="1" step="0.01" value="0" class="knob-input">
            <div class="knob-visual"></div>
        </div>
        <span id="attackValue">0.00s</span>
    </div>

    <div class="control knob-control">
        <label for="decayControl">Decay</label>
        <div class="knob-wrapper">
            <input type="range" id="decayControl" min="0" max="1" step="0.01" value="0" class="knob-input">
            <div class="knob-visual"></div>
        </div>
        <span id="decayValue">0.00s</span>
    </div>

    <div class="control knob-control">
        <label for="phaseControl">Phase</label>
        <div class="knob-wrapper">
            <input type="range" id="phaseControl" min="0" max="200" value="100" class="knob-input">
            <div class="knob-visual"></div>
        </div>
        <span id="phaseValue">100%</span>
    </div>

    <div class="control knob-control">
        <label for="harmonicsControl">Harmonics</label>
        <div class="knob-wrapper">
            <input type="range" id="harmonicsControl" min="1" max="100" value="100" class="knob-input">
            <div class="knob-visual"></div>
        </div>
        <span id="harmonicsValue">100</span>
    </div>

    <div class="control knob-control">
        <label for="reverbControl">Reverb</label>
        <div class="knob-wrapper">
            <input type="range" id="reverbControl" min="0" max="100" value="0" class="knob-input">
            <div class="knob-visual"></div>
        </div>
        <span id="reverbValue">0%</span>
    </div>

    <div class="control select-control">
        <label for="harmonicModeSelect">Mode</label>
        <select id="harmonicModeSelect">
            <option value="all">All harmonics</option>
            <option value="odd">Odd harmonics</option>
            <option value="even">Even harmonics</option>
            <option value="tonal">Tonal</option>
        </select>
    </div>

    <div class="tonal-notes hidden" id="tonalNoteSelector">
        <span class="tonal-notes__label">Notes</span>
        <div class="tonal-notes__grid">
            <label><input type="checkbox" class="tonal-note" value="C" checked>C</label>
            <label><input type="checkbox" class="tonal-note" value="#C" checked>#C</label>
            <label><input type="checkbox" class="tonal-note" value="D" checked>D</label>
            <label><input type="checkbox" class="tonal-note" value="#D" checked>#D</label>
            <label><input type="checkbox" class="tonal-note" value="E" checked>E</label>
            <label><input type="checkbox" class="tonal-note" value="F" checked>F</label>
            <label><input type="checkbox" class="tonal-note" value="#F" checked>#F</label>
            <label><input type="checkbox" class="tonal-note" value="G" checked>G</label>
            <label><input type="checkbox" class="tonal-note" value="#G" checked>#G</label>
            <label><input type="checkbox" class="tonal-note" value="A" checked>A</label>
            <label><input type="checkbox" class="tonal-note" value="#A" checked>#A</label>
            <label><input type="checkbox" class="tonal-note" value="H" checked>H</label>
            <label><input type="checkbox" class="tonal-note" value="#H" checked>#H</label>
        </div>
    </div>
</div>

<div id="content">
    <div id="canvasWrapper">
        <div class="canvas-col">
            <canvas id="canvasOriginal"></canvas>
            <canvas id="canvasR"></canvas>
            <canvas id="canvasG"></canvas>
            <canvas id="canvasB"></canvas>
        </div>
        <canvas id="highlightCanvas" width="0" height="0"></canvas>
    </div>
</div>

<script>
    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("fileInput");
    const playBtn = document.getElementById("playBtn");
    const stopBtn = document.getElementById("stopBtn");
    const detuneControl = document.getElementById("detuneControl");
    const detuneValue = document.getElementById("detuneValue");
    const stereoControl = document.getElementById("stereoControl");
    const stereoValue = document.getElementById("stereoValue");
    const speedControl = document.getElementById("speedControl");
    const speedValue = document.getElementById("speedValue");
    const contrastControl = document.getElementById("contrastControl");
    const contrastValue = document.getElementById("contrastValue");
    const baseFreqControl = document.getElementById("baseFreqControl");
    const baseFreqValue = document.getElementById("baseFreqValue");
    const attackControl = document.getElementById("attackControl");
    const attackValue = document.getElementById("attackValue");
    const decayControl = document.getElementById("decayControl");
    const decayValue = document.getElementById("decayValue");
    const harmonicsControl = document.getElementById("harmonicsControl");
    const harmonicsValue = document.getElementById("harmonicsValue");
    const phaseControl = document.getElementById("phaseControl");
    const phaseValue = document.getElementById("phaseValue");
    const reverbControl = document.getElementById("reverbControl");
    const reverbValue = document.getElementById("reverbValue");
    const harmonicModeSelect = document.getElementById("harmonicModeSelect");
    const baseFreqWrapper = document.getElementById("baseFreqWrapper");
    const octaveWrapper = document.getElementById("octaveWrapper");
    const octaveSelect = document.getElementById("octaveSelect");
    const tonalNoteSelector = document.getElementById("tonalNoteSelector");
    const tonalNoteCheckboxes = Array.from(document.querySelectorAll(".tonal-note"));

    const canvasOriginal = document.getElementById("canvasOriginal");
    const canvasR = document.getElementById("canvasR");
    const canvasG = document.getElementById("canvasG");
    const canvasB = document.getElementById("canvasB");
    const highlightCanvas = document.getElementById("highlightCanvas");

    const ctxO = canvasOriginal.getContext("2d");
    const ctxR = canvasR.getContext("2d");
    const ctxG = canvasG.getContext("2d");
    const ctxB = canvasB.getContext("2d");
    const ctxHighlight = highlightCanvas.getContext("2d");

    let audioCtx, workletNode;
    let pixelData = null;
    let basePixelData = null;
    let processedPixelData = null;
    let currentColumn = null;
    let displayScaleX = 1;
    const maxHeight = 100;

    let detuneAmount = parseFloat(detuneControl.value) / 100;
    let stereoWidth = parseFloat(stereoControl.value) / 100;
    let durationPerColumn = parseFloat(speedControl.value);
    let contrastAmount = parseFloat(contrastControl.value);
    let baseFrequency = parseFloat(baseFreqControl.value) || 100;
    let attackTime = parseFloat(attackControl.value) || 0;
    let decayTime = parseFloat(decayControl.value) || 0;
    let harmonicCount = parseInt(harmonicsControl.value, 10) || 100;
    let harmonicMode = harmonicModeSelect.value || 'all';
    let baseOctave = parseInt(octaveSelect.value, 10) || 3;
    let phaseAmount = (() => {
        const parsed = parseFloat(phaseControl.value);
        return Number.isFinite(parsed) ? parsed / 100 : 1;
    })();
    let reverbMix = parseFloat(reverbControl.value) / 100 || 0;

    let convolverNode = null;
    let dryGainNode = null;
    let wetGainNode = null;
    let reverbImpulseBuffer = null;

    const NOTE_TO_SEMITONE = Object.freeze({
        'C': 0,
        '#C': 1,
        'D': 2,
        '#D': 3,
        'E': 4,
        'F': 5,
        '#F': 6,
        'G': 7,
        '#G': 8,
        'A': 9,
        '#A': 10,
        'H': 11,
        '#H': 12
    });

    let selectedNoteNames = tonalNoteCheckboxes.filter(cb => cb.checked).map(cb => cb.value);

    const updateDetuneDisplay = () => {
        detuneValue.textContent = `${Math.round(detuneAmount * 100)}%`;
    };

    const updateStereoDisplay = () => {
        stereoValue.textContent = `${Math.round(stereoWidth * 100)}%`;
    };

    const updateSpeedDisplay = () => {
        speedValue.textContent = `${durationPerColumn.toFixed(2)}s/col`;
    };

    const updateContrastDisplay = () => {
        contrastValue.textContent = `${Math.round(contrastAmount)}%`;
    };

    const updateBaseFreqDisplay = () => {
        baseFreqValue.textContent = `${Math.round(baseFrequency)} Hz`;
    };

    const updateAttackDisplay = () => {
        attackValue.textContent = `${attackTime.toFixed(2)}s`;
    };

    const updateDecayDisplay = () => {
        decayValue.textContent = `${decayTime.toFixed(2)}s`;
    };

    const updateHarmonicsDisplay = () => {
        harmonicsValue.textContent = `${Math.round(harmonicCount)}`;
    };

    const updatePhaseDisplay = () => {
        phaseValue.textContent = `${Math.round(phaseAmount * 100)}%`;
    };

    const updateReverbDisplay = () => {
        reverbValue.textContent = `${Math.round(reverbMix * 100)}%`;
    };

    const ensureSelectedNotes = () => {
        const names = tonalNoteCheckboxes.filter(cb => cb.checked).map(cb => cb.value);
        if (names.length === 0 && tonalNoteCheckboxes.length) {
            tonalNoteCheckboxes[0].checked = true;
            return [tonalNoteCheckboxes[0].value];
        }
        return names;
    };

    const getSelectedTonalSemitones = () => {
        selectedNoteNames = ensureSelectedNotes();
        return selectedNoteNames
            .map(name => NOTE_TO_SEMITONE[name])
            .filter(n => n !== undefined);
    };

    const updateModeUI = () => {
        const isTonal = harmonicMode === 'tonal';
        if (baseFreqWrapper) baseFreqWrapper.classList.toggle('hidden', isTonal);
        if (octaveWrapper) octaveWrapper.classList.toggle('hidden', !isTonal);
        if (tonalNoteSelector) tonalNoteSelector.classList.toggle('hidden', !isTonal);
        if (isTonal) {
            selectedNoteNames = ensureSelectedNotes();
        }
    };

    const loadImpulseResponse = async (context) => {
        if (reverbImpulseBuffer) return reverbImpulseBuffer;
        try {
            const response = await fetch('impulses/stone.aif');
            if (!response.ok) throw new Error('Failed to load impulse response');
            const arrayBuffer = await response.arrayBuffer();
            reverbImpulseBuffer = await context.decodeAudioData(arrayBuffer.slice(0));
        } catch (err) {
            console.error('Impulse load error', err);
            const rate = context.sampleRate;
            const length = Math.max(1, Math.floor(rate * 1.5));
            const impulse = context.createBuffer(2, length, rate);
            for (let channel = 0; channel < impulse.numberOfChannels; channel++) {
                const data = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    const t = i / length;
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, 2.0);
                }
            }
            reverbImpulseBuffer = impulse;
        }
        return reverbImpulseBuffer;
    };

    const updateReverbMix = () => {
        const dry = Math.max(0, Math.min(1, 1 - reverbMix));
        const wet = Math.max(0, Math.min(1, reverbMix));
        if (dryGainNode && audioCtx) {
            dryGainNode.gain.setValueAtTime(dry, audioCtx.currentTime);
        }
        if (wetGainNode && audioCtx) {
            wetGainNode.gain.setValueAtTime(wet, audioCtx.currentTime);
        }
        updateReverbDisplay();
    };

    const ensureReverbNodes = async () => {
        if (!audioCtx || !workletNode) return;
        if (!convolverNode) {
            convolverNode = audioCtx.createConvolver();
            convolverNode.normalize = true;
            const buffer = await loadImpulseResponse(audioCtx);
            convolverNode.buffer = buffer;
            dryGainNode = audioCtx.createGain();
            wetGainNode = audioCtx.createGain();
            updateReverbMix();
            workletNode.connect(dryGainNode);
            workletNode.connect(convolverNode);
            convolverNode.connect(wetGainNode);
            dryGainNode.connect(audioCtx.destination);
            wetGainNode.connect(audioCtx.destination);
        }
    };

    const teardownReverbNodes = () => {
        if (workletNode && dryGainNode) workletNode.disconnect(dryGainNode);
        if (workletNode && convolverNode) workletNode.disconnect(convolverNode);
        if (dryGainNode) dryGainNode.disconnect();
        if (wetGainNode) wetGainNode.disconnect();
        if (convolverNode) convolverNode.disconnect();
        convolverNode = null;
        dryGainNode = null;
        wetGainNode = null;
    };

    const setKnobAngle = (input) => {
        if (!input) return;
        const wrapper = input.closest('.knob-wrapper');
        if (!wrapper) return;
        const visual = wrapper.querySelector('.knob-visual');
        if (!visual) return;
        const min = parseFloat(input.min ?? '0');
        const max = parseFloat(input.max ?? '100');
        const value = parseFloat(input.value ?? '0');
        if (!isFinite(min) || !isFinite(max) || max === min || !isFinite(value)) {
            visual.style.setProperty('--angle', '-135deg');
            visual.style.setProperty('--fill', '0deg');
            return;
        }
        const ratio = Math.min(1, Math.max(0, (value - min) / (max - min)));
        const sweep = ratio * 270;
        visual.style.setProperty('--fill', `${sweep}deg`);
        visual.style.setProperty('--angle', `${sweep - 135}deg`);
    };

    const registerKnob = (input) => {
        if (!input) return;
        setKnobAngle(input);
        input.addEventListener('input', () => setKnobAngle(input));
    };

    const clearHighlight = () => {
        ctxHighlight.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);
        currentColumn = null;
    };

    const drawHighlight = (column) => {
        if (!pixelData) return;
        if (!highlightCanvas.width) return;
        const start = Math.round(column * displayScaleX);
        const end = Math.round((column + 1) * displayScaleX);
        const drawWidth = Math.max(1, Math.min(highlightCanvas.width - start, end - start));
        if (drawWidth <= 0) return;
        currentColumn = column;
        ctxHighlight.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);
        ctxHighlight.fillStyle = "rgba(255, 255, 255, 0.85)";
        ctxHighlight.fillRect(start, 0, drawWidth, highlightCanvas.height);
    };

    const clampChannel = (value) => Math.max(0, Math.min(255, Math.round(value)));

    const drawChannelToCanvas = (imgData, ctxTarget, targetCanvas) => {
        const helper = document.createElement("canvas");
        helper.width = imgData.width;
        helper.height = imgData.height;
        const hctx = helper.getContext("2d");
        hctx.putImageData(imgData, 0, 0);
        ctxTarget.imageSmoothingEnabled = false;
        ctxTarget.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
        ctxTarget.drawImage(helper, 0, 0, targetCanvas.width, targetCanvas.height);
    };

    const rebuildVisuals = () => {
        if (!processedPixelData || !pixelData) return;
        const {width, height} = pixelData;
        const src = processedPixelData;
        const imgM = ctxO.createImageData(width, height);
        const imgR = ctxR.createImageData(width, height);
        const imgG = ctxG.createImageData(width, height);
        const imgB = ctxB.createImageData(width, height);

        for (let i = 0; i < src.length; i += 4) {
            const r = src[i];
            const g = src[i + 1];
            const b = src[i + 2];
            const a = src[i + 3];
            const mag = clampChannel(Math.sqrt(r * r + g * g + b * b) / Math.sqrt(3 * 255 * 255) * 255);

            imgM.data[i] = mag;
            imgM.data[i + 1] = mag;
            imgM.data[i + 2] = mag;
            imgM.data[i + 3] = a;

            imgR.data[i] = r;
            imgR.data[i + 1] = 0;
            imgR.data[i + 2] = 0;
            imgR.data[i + 3] = a;

            imgG.data[i] = 0;
            imgG.data[i + 1] = g;
            imgG.data[i + 2] = 0;
            imgG.data[i + 3] = a;

            imgB.data[i] = 0;
            imgB.data[i + 1] = 0;
            imgB.data[i + 2] = b;
            imgB.data[i + 3] = a;
        }

        drawChannelToCanvas(imgM, ctxO, canvasOriginal);
        drawChannelToCanvas(imgR, ctxR, canvasR);
        drawChannelToCanvas(imgG, ctxG, canvasG);
        drawChannelToCanvas(imgB, ctxB, canvasB);
    };

    const recomputePixelData = () => {
        if (!basePixelData) return;
        const source = basePixelData.data;
        const adjusted = new Uint8ClampedArray(source.length);
        const amount = Number.isFinite(contrastAmount) ? Math.max(0, contrastAmount) : 0;
        if (amount === 0) {
            adjusted.set(source);
        } else {
            const contrast = Math.min(150, amount * 1.5);
            const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
            for (let i = 0; i < source.length; i += 4) {
                adjusted[i] = clampChannel(factor * (source[i] - 128) + 128);
                adjusted[i + 1] = clampChannel(factor * (source[i + 1] - 128) + 128);
                adjusted[i + 2] = clampChannel(factor * (source[i + 2] - 128) + 128);
                adjusted[i + 3] = source[i + 3];
            }
        }

        processedPixelData = adjusted;
        pixelData = {
            width: basePixelData.width,
            height: basePixelData.height,
            data: adjusted
        };

        rebuildVisuals();

        if (workletNode) {
            workletNode.port.postMessage({
                type: "pixels",
                pixelData
            });
        }

        if (currentColumn !== null) {
            drawHighlight(currentColumn);
        }
    };

    updateDetuneDisplay();
    updateStereoDisplay();
    updateSpeedDisplay();
    updateContrastDisplay();
    updateBaseFreqDisplay();
    updateAttackDisplay();
    updateDecayDisplay();
    updateHarmonicsDisplay();
    updatePhaseDisplay();
    updateReverbDisplay();

    selectedNoteNames = ensureSelectedNotes();
    updateModeUI();

    [detuneControl, stereoControl, speedControl, contrastControl, baseFreqControl, attackControl, decayControl, phaseControl, harmonicsControl, reverbControl].forEach(registerKnob);

    const sendParamsToWorklet = () => {
        if (workletNode) {
            const tonalNotes = getSelectedTonalSemitones();
            workletNode.port.postMessage({
                type: "params",
                detuneAmount,
                stereoWidth,
                durationPerColumn,
                baseFrequency,
                attackTime,
                decayTime,
                harmonicCount,
                harmonicMode,
                baseOctave,
                tonalNotes,
                phaseAmount,
                reverbMix
            });
        }
    };

    detuneControl.addEventListener("input", () => {
        detuneAmount = parseFloat(detuneControl.value) / 100;
        updateDetuneDisplay();
        sendParamsToWorklet();
    });

    stereoControl.addEventListener("input", () => {
        stereoWidth = parseFloat(stereoControl.value) / 100;
        updateStereoDisplay();
        sendParamsToWorklet();
    });

    speedControl.addEventListener("input", () => {
        durationPerColumn = parseFloat(speedControl.value);
        updateSpeedDisplay();
        sendParamsToWorklet();
    });

    attackControl.addEventListener("input", () => {
        attackTime = parseFloat(attackControl.value) || 0;
        updateAttackDisplay();
        sendParamsToWorklet();
    });

    decayControl.addEventListener("input", () => {
        decayTime = parseFloat(decayControl.value) || 0;
        updateDecayDisplay();
        sendParamsToWorklet();
    });

    phaseControl.addEventListener("input", () => {
        const parsed = parseFloat(phaseControl.value);
        phaseAmount = Number.isFinite(parsed) ? parsed / 100 : phaseAmount;
        updatePhaseDisplay();
        sendParamsToWorklet();
    });

    harmonicsControl.addEventListener("input", () => {
        harmonicCount = parseInt(harmonicsControl.value, 10) || 100;
        updateHarmonicsDisplay();
        sendParamsToWorklet();
    });

    reverbControl.addEventListener("input", async () => {
        reverbMix = Math.max(0, Math.min(1, parseFloat(reverbControl.value) / 100));
        await ensureReverbNodes();
        updateReverbMix();
        sendParamsToWorklet();
    });

    harmonicModeSelect.addEventListener("change", async () => {
        harmonicMode = harmonicModeSelect.value || 'all';
        updateModeUI();
        if (harmonicMode === 'tonal') {
            await ensureReverbNodes();
        }
        sendParamsToWorklet();
    });

    if (octaveSelect) {
        octaveSelect.addEventListener("change", async () => {
            const parsed = parseInt(octaveSelect.value, 10);
            if (Number.isFinite(parsed)) {
                baseOctave = parsed;
            }
            if (harmonicMode === 'tonal') {
                await ensureReverbNodes();
                sendParamsToWorklet();
            }
        });
    }

    tonalNoteCheckboxes.forEach(cb => {
        cb.addEventListener("change", async () => {
            selectedNoteNames = ensureSelectedNotes();
            if (harmonicMode === 'tonal') {
                await ensureReverbNodes();
                sendParamsToWorklet();
            }
        });
    });

    contrastControl.addEventListener("input", () => {
        contrastAmount = parseFloat(contrastControl.value);
        updateContrastDisplay();
        recomputePixelData();
    });

    baseFreqControl.addEventListener("input", () => {
        const parsed = parseFloat(baseFreqControl.value);
        baseFrequency = Number.isFinite(parsed) ? parsed : baseFrequency;
        updateBaseFreqDisplay();
        sendParamsToWorklet();
    });

    uploadBtn.onclick = () => fileInput.click();

    fileInput.addEventListener("change", e => {
        const file = e.target.files[0];
        const img = new Image();
        img.onload = () => {
            let scale = img.height > maxHeight ? maxHeight / img.height : 1;
            const newWidth = Math.round(img.width * scale);
            const newHeight = Math.round(img.height * scale);

            // Resize for processing
            const tmpCanvas = document.createElement("canvas");
            tmpCanvas.width = newWidth;
            tmpCanvas.height = newHeight;
            const tmpCtx = tmpCanvas.getContext("2d");
            tmpCtx.drawImage(img, 0, 0, newWidth, newHeight);

            const imageData = tmpCtx.getImageData(0, 0, newWidth, newHeight);
            basePixelData = {
                width: newWidth,
                height: newHeight,
                data: new Uint8ClampedArray(imageData.data)
            };
            processedPixelData = null;
            pixelData = null;

            // Draw zoomed versions (2x size)
            [canvasOriginal, canvasR, canvasG, canvasB].forEach(c => {
                c.width = newWidth * 2;
                c.height = newHeight * 2;
                c.style.width = `${c.width}px`;
                c.style.height = `${c.height}px`;
            });

            const totalHeight = canvasOriginal.height + canvasR.height + canvasG.height + canvasB.height;
            const displayWidth = canvasOriginal.width;
            highlightCanvas.width = displayWidth;
            highlightCanvas.height = totalHeight;
            highlightCanvas.style.width = `${displayWidth}px`;
            highlightCanvas.style.height = `${totalHeight}px`;
            displayScaleX = displayWidth / newWidth;
            clearHighlight();
            recomputePixelData();
            console.log("Image loaded:", newWidth, "x", newHeight);
        };
        img.src = URL.createObjectURL(file);
    });

    playBtn.addEventListener("click", async () => {
        if (!pixelData) {
            alert("Load an image first!");
            return;
        }
        if (audioCtx && audioCtx.state !== "closed") {
            console.log("Already playing");
            return;
        }

        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        await audioCtx.resume();
        await audioCtx.audioWorklet.addModule("rgb_full_worklet.js");

        workletNode = new AudioWorkletNode(audioCtx, "rgb-full-synth");
        workletNode.port.onmessage = (event) => {
            if (event.data.type === "column") {
                drawHighlight(event.data.column);
            }
        };
        await ensureReverbNodes();
        updateReverbMix();
        clearHighlight();

        durationPerColumn = parseFloat(speedControl.value);
        detuneAmount = parseFloat(detuneControl.value) / 100;
        stereoWidth = parseFloat(stereoControl.value) / 100;
        const parsedBase = parseFloat(baseFreqControl.value);
        if (Number.isFinite(parsedBase)) {
            baseFrequency = parsedBase;
        }
        attackTime = parseFloat(attackControl.value) || 0;
        decayTime = parseFloat(decayControl.value) || 0;
        harmonicCount = parseInt(harmonicsControl.value, 10) || 100;
        harmonicMode = harmonicModeSelect.value || 'all';
        const parsedOctave = parseInt(octaveSelect.value, 10);
        if (Number.isFinite(parsedOctave)) {
            baseOctave = parsedOctave;
        }
        const parsedPhase = parseFloat(phaseControl.value);
        phaseAmount = Number.isFinite(parsedPhase) ? parsedPhase / 100 : phaseAmount;
        reverbMix = Math.max(0, Math.min(1, parseFloat(reverbControl.value) / 100 || 0));
        updateSpeedDisplay();
        updateDetuneDisplay();
        updateStereoDisplay();
        updateBaseFreqDisplay();
        updateAttackDisplay();
        updateDecayDisplay();
        updateHarmonicsDisplay();
        updatePhaseDisplay();
        updateReverbDisplay();

        {
            const tonalNotes = getSelectedTonalSemitones();
            workletNode.port.postMessage({
                type: "config",
                baseFreq: baseFrequency,
                durationPerColumn,
                detuneAmount,
                stereoWidth,
                attackTime,
                decayTime,
                harmonicCount,
                harmonicMode,
                baseOctave,
                tonalNotes,
                phaseAmount,
                reverbMix,
                sampleRate: audioCtx.sampleRate,
                pixelData
            });
        }

        console.log("Loop playback started");
    });

    stopBtn.addEventListener("click", () => {
        if (audioCtx) {
            teardownReverbNodes();
            audioCtx.close();
            audioCtx = null;
            workletNode = null;
            clearHighlight();
            console.log("Playback stopped");
        }
    });
</script>
</body>
</html>
