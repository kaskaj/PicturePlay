<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RGB Synth UI</title>
    <style>
        body {
            margin: 0;
            font-family: sans-serif;
            color: #111;
            min-height: 100vh;
            position: relative;
            background-color: #ececec;
            background-position: center;
            background-repeat: no-repeat;
            background-size: cover;
        }

        #app {
            display: flex;
            min-height: 100vh;
        }

        #controlPanel {
            width: 320px;
            padding: 14px 14px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            background: transparent;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            border-right: none;
            box-shadow: none;
        }

        .panel-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 14px;
        }

        .panel-title {
            font-size: 16px;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.92);
            font-weight: 600;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            align-items: center;
        }

        .panel-section {
            background: rgba(255, 255, 255, 0.32);
            border-radius: 12px;
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            box-shadow: 0 18px 30px rgba(17, 17, 17, 0.08);
        }

        .hidden {
            display: none !important;
        }

        .slider-control {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .toggle-control {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            color: #2f3240;
        }

        .toggle-control input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            color: #2f3240;
        }

        .slider-value {
            font-variant-numeric: tabular-nums;
            font-weight: 600;
            color: #111;
            font-size: 11px;
        }

        .slider-input {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 999px;
            background: linear-gradient(90deg, #2f3240, #2f3240) left/var(--fill-percentage, 0%) 100% no-repeat, #d9dde6;
            outline: none;
            cursor: pointer;
        }

        .slider-input:focus-visible {
            box-shadow: 0 0 0 2px rgba(47, 50, 64, 0.15);
        }

        .slider-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #111;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
        }

        .slider-input::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border: none;
            border-radius: 50%;
            background: #111;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
        }

        .select-control {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .select-control label {
            font-size: 11px;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            color: #2f3240;
        }

        .select-control select {
            background: #f1f3f8;
            color: #111;
            border: 1px solid #d2d7e1;
            padding: 6px 10px;
            border-radius: 9px;
            font-size: 13px;
        }

        button {
            background: #fff;
            color: #111;
            border: none;
            border-radius: 6px;
            padding: 10px 14px;
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s ease, color 0.2s ease;
        }

        button:hover {
            background: #ebedf5;
        }

        button:active {
            transform: translateY(1px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .icon-button {
            position: relative;
            width: 36px;
            height: 36px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            padding: 0;
        }

        .icon-button::before,
        .icon-button::after {
            content: "";
            position: absolute;
            display: block;
            background: none;
        }

        .icon-button.icon-upload::before,
        .icon-button.icon-upload::after {
            content: none;
        }

        .icon-button.icon-play::before {
            width: 0;
            height: 0;
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            border-left: 14px solid #111;
            left: 52%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .icon-button.icon-stop::before {
            width: 16px;
            height: 16px;
            background: #111;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .icon-button .icon-image {
            width: 20px;
            height: auto;
            display: block;
            pointer-events: none;
        }

        .slider-input:disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }

        .slider-control.is-disabled {
            opacity: 0.5;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .tonal-notes {
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: #f5f7fc;
            padding: 10px;
            border-radius: 10px;
            border: 1px solid #e0e4ef;
            color: #2f3240;
        }

        .tonal-notes__label {
            font-size: 11px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .tonal-notes__grid {
            display: grid;
            grid-template-columns: repeat(6, minmax(0, 1fr));
            gap: 6px 12px;
            font-size: 12px;
        }

        .tonal-notes__grid label {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
        }

        .tonal-notes__grid input {
            accent-color: #2f3240;
        }

        #content {
            flex: 1;
            position: relative;
            padding: 24px;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow: auto;
        }

        #canvasWrapper {
            position: relative;
            display: inline-block;
        }

        .canvas-shell {
            position: relative;
            background: rgba(255, 255, 255, 0.45);
            padding: 14px;
            border-radius: 16px;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 0 25px 45px rgba(17, 17, 17, 0.12);
        }

        .canvas-col {
            display: flex;
            flex-direction: column;
        }

        #highlightCanvas {
            position: absolute;
            top: 14px;
            left: 14px;
            pointer-events: none;
            z-index: 2;
        }

        canvas {
            display: block;
            margin: 0;
            padding: 0;
            image-rendering: pixelated; /* makes zoomed pixels crisp */
            border: none;
        }
    </style>
</head>
<body>
<div id="app">
    <aside id="controlPanel">
        <div class="panel-actions">
            <input type="file" id="fileInput" accept="image/*" style="display:none;">
            <div class="panel-header">
                <span class="panel-title">RGB Synth</span>
                <div class="action-buttons">
                    <button id="uploadBtn" class="icon-button icon-upload" title="Upload">
                        <span class="sr-only">Upload</span>
                        <img src="icon_picture.png" alt="" class="icon-image">
                    </button>
                    <button id="playBtn" class="icon-button icon-play" title="Play">
                        <span class="sr-only">Play</span>
                    </button>
                    <button id="stopBtn" class="icon-button icon-stop" title="Stop">
                        <span class="sr-only">Stop</span>
                    </button>
                </div>
            </div>
        </div>

        <div class="panel-section">
            <div class="slider-control">
                <div class="slider-header">
                    <label for="detuneControl">G → Detune</label>
                    <span class="slider-value" id="detuneValue">10%</span>
                </div>
                <input type="range" id="detuneControl" min="0" max="200" value="10" class="slider-input">
            </div>
            <div class="slider-control">
                <div class="slider-header">
                    <label for="phaseControl">R → Phase</label>
                    <span class="slider-value" id="phaseValue">100%</span>
                </div>
                <input type="range" id="phaseControl" min="0" max="200" value="100" class="slider-input">
            </div>
            <div class="slider-control">
                <div class="slider-header">
                    <label for="stereoControl">B → Stereo</label>
                    <span class="slider-value" id="stereoValue">50%</span>
                </div>
                <input type="range" id="stereoControl" min="0" max="100" value="50" class="slider-input">
            </div>
        </div>

        <div class="panel-section">
            <div class="slider-control">
                <div class="slider-header">
                    <label for="contrastControl">Contrast</label>
                    <span class="slider-value" id="contrastValue">0%</span>
                </div>
                <input type="range" id="contrastControl" min="0" max="100" value="0" class="slider-input">
            </div>
            <div class="slider-control">
                <div class="slider-header">
                    <label for="brightnessControl">Brightness</label>
                    <span class="slider-value" id="brightnessValue">0%</span>
                </div>
                <input type="range" id="brightnessControl" min="-100" max="100" value="0" class="slider-input">
            </div>
            <div class="slider-control">
                <label class="toggle-control" for="invertToggle">
                    <input type="checkbox" id="invertToggle">
                    <span>Invert Colors</span>
                </label>
            </div>
        </div>

        <div class="panel-section">
            <div class="slider-control" id="baseFreqWrapper">
                <div class="slider-header">
                    <label for="baseFreqControl">Base Freq</label>
                    <span class="slider-value" id="baseFreqValue">100 Hz</span>
                </div>
                <input type="range" id="baseFreqControl" min="20" max="1000" value="100" class="slider-input">
            </div>
            <div class="slider-control">
                <div class="slider-header">
                    <label for="speedControl">Speed</label>
                    <span class="slider-value" id="speedValue">100 ms/px</span>
                </div>
                <input type="range" id="speedControl" min="0.01" max="0.5" step="0.01" value="0.1" class="slider-input">
            </div>
            <div class="slider-control">
                <div class="slider-header">
                    <label for="harmonicsControl">Harmonics</label>
                    <span class="slider-value" id="harmonicsValue">100</span>
                </div>
                <input type="range" id="harmonicsControl" min="1" max="100" value="100" class="slider-input">
            </div>
            <div class="select-control">
                <label for="harmonicModeSelect">Mode</label>
                <select id="harmonicModeSelect">
                    <option value="all">All harmonics</option>
                    <option value="odd">Odd harmonics</option>
                    <option value="even">Even harmonics</option>
                    <option value="tonal">Tonal</option>
                </select>
            </div>
            <div class="select-control hidden" id="octaveWrapper">
                <label for="octaveSelect">Octave</label>
                <select id="octaveSelect">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                </select>
            </div>
            <div class="tonal-notes hidden" id="tonalNoteSelector">
                <span class="tonal-notes__label">Notes</span>
                <div class="tonal-notes__grid">
                    <label><input type="checkbox" class="tonal-note" value="C" checked>C</label>
                    <label><input type="checkbox" class="tonal-note" value="#C" checked>#C</label>
                    <label><input type="checkbox" class="tonal-note" value="D" checked>D</label>
                    <label><input type="checkbox" class="tonal-note" value="#D" checked>#D</label>
                    <label><input type="checkbox" class="tonal-note" value="E" checked>E</label>
                    <label><input type="checkbox" class="tonal-note" value="F" checked>F</label>
                    <label><input type="checkbox" class="tonal-note" value="#F" checked>#F</label>
                    <label><input type="checkbox" class="tonal-note" value="G" checked>G</label>
                    <label><input type="checkbox" class="tonal-note" value="#G" checked>#G</label>
                    <label><input type="checkbox" class="tonal-note" value="A" checked>A</label>
                    <label><input type="checkbox" class="tonal-note" value="#A" checked>#A</label>
                    <label><input type="checkbox" class="tonal-note" value="H" checked>H</label>
                    <label><input type="checkbox" class="tonal-note" value="#H" checked>#H</label>
                </div>
            </div>
        </div>

        <div class="panel-section">
            <div class="slider-control">
                <div class="slider-header">
                    <label for="attackControl">Attack</label>
                    <span class="slider-value" id="attackValue">0%</span>
                </div>
                <input type="range" id="attackControl" min="0" max="100" step="1" value="0" class="slider-input">
            </div>
            <div class="slider-control">
                <div class="slider-header">
                    <label for="decayControl">Decay</label>
                    <span class="slider-value" id="decayValue">0%</span>
                </div>
                <input type="range" id="decayControl" min="0" max="100" step="1" value="0" class="slider-input">
            </div>
        </div>

        <div class="panel-section">
            <div class="slider-control">
                <div class="slider-header">
                    <label for="reverbControl">Reverb</label>
                    <span class="slider-value" id="reverbValue">0%</span>
                </div>
                <input type="range" id="reverbControl" min="0" max="100" value="0" class="slider-input">
            </div>
            <div class="slider-control">
                <div class="slider-header">
                    <label for="lowEQControl">Low EQ</label>
                    <span class="slider-value" id="lowEQValue">+4 dB</span>
                </div>
                <input type="range" id="lowEQControl" min="-12" max="12" step="1" value="4" class="slider-input">
            </div>
            <div class="slider-control">
                <div class="slider-header">
                    <label for="midEQControl">Mid EQ</label>
                    <span class="slider-value" id="midEQValue">0 dB</span>
                </div>
                <input type="range" id="midEQControl" min="-12" max="12" step="1" value="0" class="slider-input">
            </div>
            <div class="slider-control">
                <div class="slider-header">
                    <label for="highEQControl">High EQ</label>
                    <span class="slider-value" id="highEQValue">-4 dB</span>
                </div>
                <input type="range" id="highEQControl" min="-12" max="12" step="1" value="-4" class="slider-input">
            </div>
        </div>
    </aside>

    <main id="content">
        <div id="canvasWrapper">
            <div class="canvas-shell">
                <div class="canvas-col">
                    <canvas id="canvasOriginal"></canvas>
                    <canvas id="canvasR"></canvas>
                    <canvas id="canvasG"></canvas>
                    <canvas id="canvasB"></canvas>
                </div>
                <canvas id="highlightCanvas" width="0" height="0"></canvas>
            </div>
        </div>
    </main>
</div>

<script>
    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("fileInput");
    const playBtn = document.getElementById("playBtn");
    const stopBtn = document.getElementById("stopBtn");
    const detuneControl = document.getElementById("detuneControl");
    const detuneValue = document.getElementById("detuneValue");
    const stereoControl = document.getElementById("stereoControl");
    const stereoValue = document.getElementById("stereoValue");
    const speedControl = document.getElementById("speedControl");
    const speedValue = document.getElementById("speedValue");
    const contrastControl = document.getElementById("contrastControl");
    const contrastValue = document.getElementById("contrastValue");
    const brightnessControl = document.getElementById("brightnessControl");
    const brightnessValue = document.getElementById("brightnessValue");
    const lowEQControl = document.getElementById("lowEQControl");
    const lowEQValue = document.getElementById("lowEQValue");
    const midEQControl = document.getElementById("midEQControl");
    const midEQValue = document.getElementById("midEQValue");
    const highEQControl = document.getElementById("highEQControl");
    const highEQValue = document.getElementById("highEQValue");
    const baseFreqControl = document.getElementById("baseFreqControl");
    const baseFreqValue = document.getElementById("baseFreqValue");
    const attackControl = document.getElementById("attackControl");
    const attackValue = document.getElementById("attackValue");
    const decayControl = document.getElementById("decayControl");
    const decayValue = document.getElementById("decayValue");
    const harmonicsControl = document.getElementById("harmonicsControl");
    const harmonicsValue = document.getElementById("harmonicsValue");
    const phaseControl = document.getElementById("phaseControl");
    const phaseValue = document.getElementById("phaseValue");
    const reverbControl = document.getElementById("reverbControl");
    const reverbValue = document.getElementById("reverbValue");
    const invertToggle = document.getElementById("invertToggle");
    const harmonicModeSelect = document.getElementById("harmonicModeSelect");
    const baseFreqWrapper = document.getElementById("baseFreqWrapper");
    const octaveWrapper = document.getElementById("octaveWrapper");
    const octaveSelect = document.getElementById("octaveSelect");
    const tonalNoteSelector = document.getElementById("tonalNoteSelector");
    const tonalNoteCheckboxes = Array.from(document.querySelectorAll(".tonal-note"));
    const content = document.getElementById("content");
    const appBody = document.body;

    const canvasOriginal = document.getElementById("canvasOriginal");
    const canvasR = document.getElementById("canvasR");
    const canvasG = document.getElementById("canvasG");
    const canvasB = document.getElementById("canvasB");
    const highlightCanvas = document.getElementById("highlightCanvas");

    const ctxO = canvasOriginal.getContext("2d");
    const ctxR = canvasR.getContext("2d");
    const ctxG = canvasG.getContext("2d");
    const ctxB = canvasB.getContext("2d");
    const ctxHighlight = highlightCanvas.getContext("2d");

    let audioCtx, workletNode;
    let pixelData = null;
    let basePixelData = null;
    let processedPixelData = null;
    let currentColumn = null;
    let displayScaleX = 1;
    const maxHeight = 100;

    let detuneAmount = parseFloat(detuneControl.value) / 100;
    let stereoWidth = parseFloat(stereoControl.value) / 100;
    let durationPerColumn = parseFloat(speedControl.value);
    let contrastAmount = parseFloat(contrastControl.value);
    let brightnessAmount = parseFloat(brightnessControl.value) || 0;
    let invertImage = invertToggle ? invertToggle.checked : false;
    let eqLowGainDb = parseFloat(lowEQControl.value) || 0;
    let eqMidGainDb = parseFloat(midEQControl.value) || 0;
    let eqHighGainDb = parseFloat(highEQControl.value) || 0;
    let baseFrequency = parseFloat(baseFreqControl.value) || 100;
    let harmonicCount = parseInt(harmonicsControl.value, 10) || 100;
    let harmonicMode = harmonicModeSelect.value || 'all';
    let baseOctave = parseInt(octaveSelect.value, 10) || 3;
    let phaseAmount = (() => {
        const parsed = parseFloat(phaseControl.value);
        return Number.isFinite(parsed) ? parsed / 100 : 1;
    })();
    let reverbMix = parseFloat(reverbControl.value) / 100 || 0;
    let currentImageURL = null;

    let convolverNode = null;
    let dryGainNode = null;
    let wetGainNode = null;
    let reverbImpulseBuffer = null;
    let eqLowNode = null;
    let eqMidNode = null;
    let eqHighNode = null;
    let eqOutputConnected = false;

    const NOTE_TO_SEMITONE = Object.freeze({
        'C': 0,
        '#C': 1,
        'D': 2,
        '#D': 3,
        'E': 4,
        'F': 5,
        '#F': 6,
        'G': 7,
        '#G': 8,
        'A': 9,
        '#A': 10,
        'H': 11,
        '#H': 12
    });

    let selectedNoteNames = tonalNoteCheckboxes.filter(cb => cb.checked).map(cb => cb.value);

    const updateDetuneDisplay = () => {
        setSliderFill(detuneControl);
        detuneValue.textContent = `${Math.round(detuneAmount * 100)}%`;
    };

    const updateStereoDisplay = () => {
        setSliderFill(stereoControl);
        stereoValue.textContent = `${Math.round(stereoWidth * 100)}%`;
    };

    const updateSpeedDisplay = () => {
        setSliderFill(speedControl);
        speedValue.textContent = `${(durationPerColumn * 1000).toFixed(0)} ms/px`;
    };

    const updateContrastDisplay = () => {
        setSliderFill(contrastControl);
        contrastValue.textContent = `${Math.round(contrastAmount)}%`;
    };

    const clamp01 = (value) => Math.min(1, Math.max(0, value));

    const getSliderPercentValue = (input) => {
        if (!input) return 0;
        const raw = parseFloat(input.value);
        return Number.isFinite(raw) ? clamp01(raw / 100) : 0;
    };

    let attackRatio = getSliderPercentValue(attackControl);
    let decayRatio = getSliderPercentValue(decayControl);
    let attackTime = attackRatio * durationPerColumn;
    let decayTime = decayRatio * durationPerColumn;

    const updateBrightnessDisplay = () => {
        if (!brightnessControl) return;
        setSliderFill(brightnessControl);
        const value = Math.round(brightnessAmount);
        const prefix = value > 0 ? '+' : '';
        brightnessValue.textContent = `${prefix}${value}%`;
    };

    const formatDb = (value) => {
        const rounded = Math.round(value);
        const prefix = rounded > 0 ? '+' : '';
        return `${prefix}${rounded} dB`;
    };

    const updateLowEQDisplay = () => {
        if (!lowEQControl) return;
        setSliderFill(lowEQControl);
        lowEQValue.textContent = formatDb(eqLowGainDb);
    };

    const updateMidEQDisplay = () => {
        if (!midEQControl) return;
        setSliderFill(midEQControl);
        midEQValue.textContent = formatDb(eqMidGainDb);
    };

    const updateHighEQDisplay = () => {
        if (!highEQControl) return;
        setSliderFill(highEQControl);
        highEQValue.textContent = formatDb(eqHighGainDb);
    };

    const updateBaseFreqDisplay = () => {
        setSliderFill(baseFreqControl);
        baseFreqValue.textContent = `${Math.round(baseFrequency)} Hz`;
    };

    const updateAttackDisplay = () => {
        setSliderFill(attackControl);
        attackValue.textContent = `${Math.round(attackRatio * 100)}%`;
    };

    const updateDecayDisplay = () => {
        setSliderFill(decayControl);
        decayValue.textContent = `${Math.round(decayRatio * 100)}%`;
    };

    const updateHarmonicsDisplay = () => {
        setSliderFill(harmonicsControl);
        harmonicsValue.textContent = `${Math.round(harmonicCount)}`;
    };

    const updatePhaseDisplay = () => {
        setSliderFill(phaseControl);
        phaseValue.textContent = `${Math.round(phaseAmount * 100)}%`;
    };

    const updateReverbDisplay = () => {
        setSliderFill(reverbControl);
        reverbValue.textContent = `${Math.round(reverbMix * 100)}%`;
    };

    const ensureSelectedNotes = () => {
        const names = tonalNoteCheckboxes.filter(cb => cb.checked).map(cb => cb.value);
        if (names.length === 0 && tonalNoteCheckboxes.length) {
            tonalNoteCheckboxes[0].checked = true;
            return [tonalNoteCheckboxes[0].value];
        }
        return names;
    };

    const getSelectedTonalSemitones = () => {
        selectedNoteNames = ensureSelectedNotes();
        return selectedNoteNames
            .map(name => NOTE_TO_SEMITONE[name])
            .filter(n => n !== undefined);
    };

    const updateModeUI = () => {
        const isTonal = harmonicMode === 'tonal';
        if (baseFreqWrapper) baseFreqWrapper.classList.toggle('is-disabled', isTonal);
        if (baseFreqControl) {
            baseFreqControl.disabled = isTonal;
            updateBaseFreqDisplay();
        }
        if (octaveWrapper) octaveWrapper.classList.toggle('hidden', !isTonal);
        if (tonalNoteSelector) tonalNoteSelector.classList.toggle('hidden', !isTonal);
        if (isTonal) {
            selectedNoteNames = ensureSelectedNotes();
        }
    };

    const loadImpulseResponse = async (context) => {
        if (reverbImpulseBuffer) return reverbImpulseBuffer;
        try {
            const response = await fetch('impulses/stone.aif');
            if (!response.ok) throw new Error('Failed to load impulse response');
            const arrayBuffer = await response.arrayBuffer();
            reverbImpulseBuffer = await context.decodeAudioData(arrayBuffer.slice(0));
        } catch (err) {
            console.error('Impulse load error', err);
            const rate = context.sampleRate;
            const length = Math.max(1, Math.floor(rate * 1.5));
            const impulse = context.createBuffer(2, length, rate);
            for (let channel = 0; channel < impulse.numberOfChannels; channel++) {
                const data = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    const t = i / length;
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, 2.0);
                }
            }
            reverbImpulseBuffer = impulse;
        }
        return reverbImpulseBuffer;
    };

    const updateReverbMix = () => {
        const dry = Math.max(0, Math.min(1, 1 - reverbMix));
        const wet = Math.max(0, Math.min(1, reverbMix));
        if (dryGainNode && audioCtx) {
            dryGainNode.gain.setValueAtTime(dry, audioCtx.currentTime);
        }
        if (wetGainNode && audioCtx) {
            wetGainNode.gain.setValueAtTime(wet, audioCtx.currentTime);
        }
        updateReverbDisplay();
    };

    const ensureReverbNodes = async () => {
        if (!audioCtx || !workletNode) return;
        const eqOutput = ensureEQNodes();
        if (!eqOutput) return;

        if (!convolverNode) {
            convolverNode = audioCtx.createConvolver();
            convolverNode.normalize = true;
            const buffer = await loadImpulseResponse(audioCtx);
            convolverNode.buffer = buffer;
            dryGainNode = audioCtx.createGain();
            wetGainNode = audioCtx.createGain();
            updateEQFilters();
            updateReverbMix();
            eqOutput.connect(dryGainNode);
            eqOutput.connect(convolverNode);
            convolverNode.connect(wetGainNode);
            dryGainNode.connect(audioCtx.destination);
            wetGainNode.connect(audioCtx.destination);
            eqOutputConnected = true;
        } else if (!eqOutputConnected) {
            eqOutput.connect(dryGainNode);
            eqOutput.connect(convolverNode);
            eqOutputConnected = true;
        }
    };

    const teardownReverbNodes = () => {
        if (eqHighNode && dryGainNode) {
            try { eqHighNode.disconnect(dryGainNode); } catch (err) {}
        }
        if (eqHighNode && convolverNode) {
            try { eqHighNode.disconnect(convolverNode); } catch (err) {}
        }
        if (dryGainNode) dryGainNode.disconnect();
        if (wetGainNode) wetGainNode.disconnect();
        if (convolverNode) convolverNode.disconnect();
        if (workletNode && eqLowNode) {
            try { workletNode.disconnect(eqLowNode); } catch (err) {}
        }
        if (workletNode) {
            try { workletNode.disconnect(); } catch (err) {}
        }
        if (eqLowNode) {
            try { eqLowNode.disconnect(); } catch (err) {}
        }
        if (eqMidNode) {
            try { eqMidNode.disconnect(); } catch (err) {}
        }
        if (eqHighNode) {
            try { eqHighNode.disconnect(); } catch (err) {}
        }
        convolverNode = null;
        dryGainNode = null;
        wetGainNode = null;
        eqLowNode = null;
        eqMidNode = null;
        eqHighNode = null;
        eqOutputConnected = false;
    };

    const setSliderFill = (input) => {
        if (!input) return;
        const min = parseFloat(input.min ?? '0');
        const max = parseFloat(input.max ?? '100');
        const value = parseFloat(input.value ?? '0');
        if (!Number.isFinite(min) || !Number.isFinite(max) || max === min || !Number.isFinite(value)) {
            input.style.removeProperty('--fill-percentage');
            return;
        }
        const ratio = Math.min(1, Math.max(0, (value - min) / (max - min)));
        input.style.setProperty('--fill-percentage', `${ratio * 100}%`);
    };

    const registerSlider = (input) => {
        if (!input) return;
        setSliderFill(input);
        input.addEventListener('input', () => setSliderFill(input));
        input.addEventListener('change', () => setSliderFill(input));
    };

    const recalcEnvelopeTimes = () => {
        attackTime = attackRatio * durationPerColumn;
        decayTime = decayRatio * durationPerColumn;
    };

    const clearHighlight = () => {
        ctxHighlight.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);
        currentColumn = null;
    };

    const drawHighlight = (column) => {
        if (!pixelData) return;
        if (!highlightCanvas.width) return;
        const start = Math.round(column * displayScaleX);
        const end = Math.round((column + 1) * displayScaleX);
        const drawWidth = Math.max(1, Math.min(highlightCanvas.width - start, end - start));
        if (drawWidth <= 0) return;
        currentColumn = column;
        ctxHighlight.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);
        ctxHighlight.fillStyle = "rgba(255, 255, 255, 0.85)";
        ctxHighlight.fillRect(start, 0, drawWidth, highlightCanvas.height);
    };

    const clampChannel = (value) => Math.max(0, Math.min(255, Math.round(value)));

    const applyBrightnessShift = (value, strength) => {
        if (strength === 0) return value;
        if (strength > 0) {
            return clampChannel(value + (255 - value) * strength);
        }
        return clampChannel(value * (1 + strength));
    };

    const applyContrastValue = (value, factor) => clampChannel(factor * (value - 128) + 128);

    const updateEQFilters = () => {
        if (eqLowNode) eqLowNode.gain.value = eqLowGainDb;
        if (eqMidNode) eqMidNode.gain.value = eqMidGainDb;
        if (eqHighNode) eqHighNode.gain.value = eqHighGainDb;
    };

    const ensureEQNodes = () => {
        if (!audioCtx || !workletNode) return null;
        if (!eqLowNode) {
            try { workletNode.disconnect(); } catch (err) {}
            eqLowNode = audioCtx.createBiquadFilter();
            eqLowNode.type = "lowshelf";
            eqLowNode.frequency.value = 200;

            eqMidNode = audioCtx.createBiquadFilter();
            eqMidNode.type = "peaking";
            eqMidNode.frequency.value = 1000;
            eqMidNode.Q.value = 1;

            eqHighNode = audioCtx.createBiquadFilter();
            eqHighNode.type = "highshelf";
            eqHighNode.frequency.value = 4000;

            workletNode.connect(eqLowNode);
            eqLowNode.connect(eqMidNode);
            eqMidNode.connect(eqHighNode);
            eqOutputConnected = false;
        }
        updateEQFilters();
        return eqHighNode;
    };

    const drawChannelToCanvas = (imgData, ctxTarget, targetCanvas) => {
        const helper = document.createElement("canvas");
        helper.width = imgData.width;
        helper.height = imgData.height;
        const hctx = helper.getContext("2d");
        hctx.putImageData(imgData, 0, 0);
        ctxTarget.imageSmoothingEnabled = false;
        ctxTarget.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
        ctxTarget.drawImage(helper, 0, 0, targetCanvas.width, targetCanvas.height);
    };

    const rebuildVisuals = () => {
        if (!processedPixelData || !pixelData) return;
        const {width, height} = pixelData;
        const src = processedPixelData;
        const imgM = ctxO.createImageData(width, height);
        const imgR = ctxR.createImageData(width, height);
        const imgG = ctxG.createImageData(width, height);
        const imgB = ctxB.createImageData(width, height);

        for (let i = 0; i < src.length; i += 4) {
            const r = src[i];
            const g = src[i + 1];
            const b = src[i + 2];
            const a = src[i + 3];
            const mag = clampChannel(Math.sqrt(r * r + g * g + b * b) / Math.sqrt(3 * 255 * 255) * 255);

            imgM.data[i] = mag;
            imgM.data[i + 1] = mag;
            imgM.data[i + 2] = mag;
            imgM.data[i + 3] = a;

            imgR.data[i] = r;
            imgR.data[i + 1] = 0;
            imgR.data[i + 2] = 0;
            imgR.data[i + 3] = a;

            imgG.data[i] = 0;
            imgG.data[i + 1] = g;
            imgG.data[i + 2] = 0;
            imgG.data[i + 3] = a;

            imgB.data[i] = 0;
            imgB.data[i + 1] = 0;
            imgB.data[i + 2] = b;
            imgB.data[i + 3] = a;
        }

        drawChannelToCanvas(imgM, ctxO, canvasOriginal);
        drawChannelToCanvas(imgR, ctxR, canvasR);
        drawChannelToCanvas(imgG, ctxG, canvasG);
        drawChannelToCanvas(imgB, ctxB, canvasB);
    };

    const recomputePixelData = () => {
        if (!basePixelData) return;
        const {width, height, data: source} = basePixelData;
        const adjusted = new Uint8ClampedArray(source.length);

        const brightnessStrength = Number.isFinite(brightnessAmount) ? Math.max(-1, Math.min(1, brightnessAmount / 100)) : 0;
        const applyContrast = Number.isFinite(contrastAmount) && contrastAmount > 0;
        let contrastFactor = 1;
        if (applyContrast) {
            const contrast = Math.min(150, contrastAmount * 1.5);
            contrastFactor = (259 * (contrast + 255)) / (255 * (259 - contrast));
        }

        for (let i = 0; i < source.length; i += 4) {
            let r = source[i];
            let g = source[i + 1];
            let b = source[i + 2];

            if (brightnessStrength !== 0) {
                r = applyBrightnessShift(r, brightnessStrength);
                g = applyBrightnessShift(g, brightnessStrength);
                b = applyBrightnessShift(b, brightnessStrength);
            }

            if (invertImage) {
                r = 255 - r;
                g = 255 - g;
                b = 255 - b;
            }

            if (applyContrast) {
                r = applyContrastValue(r, contrastFactor);
                g = applyContrastValue(g, contrastFactor);
                b = applyContrastValue(b, contrastFactor);
            }

            adjusted[i] = r;
            adjusted[i + 1] = g;
            adjusted[i + 2] = b;
            adjusted[i + 3] = source[i + 3];
        }

        processedPixelData = adjusted;
        pixelData = {
            width,
            height,
            data: adjusted
        };

        rebuildVisuals();

        if (workletNode) {
            workletNode.port.postMessage({
                type: "pixels",
                pixelData
            });
        }

        if (currentColumn !== null) {
            drawHighlight(currentColumn);
        }
    };

    updateDetuneDisplay();
    updateStereoDisplay();
    updateSpeedDisplay();
    updateContrastDisplay();
    updateBrightnessDisplay();
    updateBaseFreqDisplay();
    updateAttackDisplay();
    updateDecayDisplay();
    updateHarmonicsDisplay();
    updatePhaseDisplay();
    updateReverbDisplay();
    updateLowEQDisplay();
    updateMidEQDisplay();
    updateHighEQDisplay();

    selectedNoteNames = ensureSelectedNotes();
    updateModeUI();

    [detuneControl, stereoControl, speedControl, contrastControl, brightnessControl, baseFreqControl, attackControl, decayControl, phaseControl, harmonicsControl, reverbControl, lowEQControl, midEQControl, highEQControl].forEach(registerSlider);

    const sendParamsToWorklet = () => {
        recalcEnvelopeTimes();
        if (workletNode) {
            const tonalNotes = getSelectedTonalSemitones();
            workletNode.port.postMessage({
                type: "params",
                detuneAmount,
                stereoWidth,
                durationPerColumn,
                baseFrequency,
                attackTime,
                decayTime,
                harmonicCount,
                harmonicMode,
                baseOctave,
                tonalNotes,
                phaseAmount,
                reverbMix
            });
        }
    };

    detuneControl.addEventListener("input", () => {
        detuneAmount = parseFloat(detuneControl.value) / 100;
        updateDetuneDisplay();
        sendParamsToWorklet();
    });

    stereoControl.addEventListener("input", () => {
        stereoWidth = parseFloat(stereoControl.value) / 100;
        updateStereoDisplay();
        sendParamsToWorklet();
    });

    speedControl.addEventListener("input", () => {
        const parsed = parseFloat(speedControl.value);
        if (Number.isFinite(parsed)) {
            durationPerColumn = parsed;
        }
        recalcEnvelopeTimes();
        updateSpeedDisplay();
        updateAttackDisplay();
        updateDecayDisplay();
        sendParamsToWorklet();
    });

    attackControl.addEventListener("input", () => {
        attackRatio = getSliderPercentValue(attackControl);
        recalcEnvelopeTimes();
        updateAttackDisplay();
        sendParamsToWorklet();
    });

    decayControl.addEventListener("input", () => {
        decayRatio = getSliderPercentValue(decayControl);
        recalcEnvelopeTimes();
        updateDecayDisplay();
        sendParamsToWorklet();
    });

    phaseControl.addEventListener("input", () => {
        const parsed = parseFloat(phaseControl.value);
        phaseAmount = Number.isFinite(parsed) ? parsed / 100 : phaseAmount;
        updatePhaseDisplay();
        sendParamsToWorklet();
    });

    harmonicsControl.addEventListener("input", () => {
        harmonicCount = parseInt(harmonicsControl.value, 10) || 100;
        updateHarmonicsDisplay();
        sendParamsToWorklet();
    });

    reverbControl.addEventListener("input", async () => {
        reverbMix = Math.max(0, Math.min(1, parseFloat(reverbControl.value) / 100));
        await ensureReverbNodes();
        updateReverbMix();
        sendParamsToWorklet();
    });

    harmonicModeSelect.addEventListener("change", async () => {
        harmonicMode = harmonicModeSelect.value || 'all';
        updateModeUI();
        if (harmonicMode === 'tonal') {
            await ensureReverbNodes();
        }
        sendParamsToWorklet();
    });

    if (octaveSelect) {
        octaveSelect.addEventListener("change", async () => {
            const parsed = parseInt(octaveSelect.value, 10);
            if (Number.isFinite(parsed)) {
                baseOctave = parsed;
            }
            if (harmonicMode === 'tonal') {
                await ensureReverbNodes();
                sendParamsToWorklet();
            }
        });
    }

    tonalNoteCheckboxes.forEach(cb => {
        cb.addEventListener("change", async () => {
            selectedNoteNames = ensureSelectedNotes();
            if (harmonicMode === 'tonal') {
                await ensureReverbNodes();
                sendParamsToWorklet();
            }
        });
    });

    contrastControl.addEventListener("input", () => {
        contrastAmount = parseFloat(contrastControl.value);
        updateContrastDisplay();
        recomputePixelData();
    });

    if (brightnessControl) {
        brightnessControl.addEventListener("input", () => {
            brightnessAmount = parseFloat(brightnessControl.value) || 0;
            updateBrightnessDisplay();
            recomputePixelData();
        });
    }

    const handleEQChange = () => {
        updateLowEQDisplay();
        updateMidEQDisplay();
        updateHighEQDisplay();
        updateEQFilters();
    };

    if (invertToggle) {
        invertToggle.addEventListener("change", () => {
            invertImage = invertToggle.checked;
            recomputePixelData();
        });
    }

    if (lowEQControl) {
        lowEQControl.addEventListener("input", () => {
            eqLowGainDb = parseFloat(lowEQControl.value) || 0;
            handleEQChange();
        });
    }

    if (midEQControl) {
        midEQControl.addEventListener("input", () => {
            eqMidGainDb = parseFloat(midEQControl.value) || 0;
            handleEQChange();
        });
    }

    if (highEQControl) {
        highEQControl.addEventListener("input", () => {
            eqHighGainDb = parseFloat(highEQControl.value) || 0;
            handleEQChange();
        });
    }

    baseFreqControl.addEventListener("input", () => {
        const parsed = parseFloat(baseFreqControl.value);
        baseFrequency = Number.isFinite(parsed) ? parsed : baseFrequency;
        updateBaseFreqDisplay();
        sendParamsToWorklet();
    });

    uploadBtn.onclick = () => fileInput.click();

    fileInput.addEventListener("change", e => {
        const file = e.target.files[0];
        if (!file) return;
        const objectURL = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => {
            if (currentImageURL) {
                URL.revokeObjectURL(currentImageURL);
            }
            currentImageURL = objectURL;
            if (appBody) {
                appBody.style.backgroundImage = `url('${currentImageURL}')`;
                appBody.style.backgroundPosition = "center center";
                appBody.style.backgroundRepeat = "no-repeat";
                if (img.width >= img.height) {
                    appBody.style.backgroundSize = "auto 100%";
                } else {
                    appBody.style.backgroundSize = "100% auto";
                }
            }
            let scale = img.height > maxHeight ? maxHeight / img.height : 1;
            const newWidth = Math.round(img.width * scale);
            const newHeight = Math.round(img.height * scale);

            // Resize for processing
            const tmpCanvas = document.createElement("canvas");
            tmpCanvas.width = newWidth;
            tmpCanvas.height = newHeight;
            const tmpCtx = tmpCanvas.getContext("2d");
            tmpCtx.drawImage(img, 0, 0, newWidth, newHeight);

            const imageData = tmpCtx.getImageData(0, 0, newWidth, newHeight);
            basePixelData = {
                width: newWidth,
                height: newHeight,
                data: new Uint8ClampedArray(imageData.data)
            };
            processedPixelData = null;
            pixelData = null;

            // Draw zoomed versions (2x size)
            [canvasOriginal, canvasR, canvasG, canvasB].forEach(c => {
                c.width = newWidth * 2;
                c.height = newHeight * 2;
                c.style.width = `${c.width}px`;
                c.style.height = `${c.height}px`;
            });

            const totalHeight = canvasOriginal.height + canvasR.height + canvasG.height + canvasB.height;
            const displayWidth = canvasOriginal.width;
            highlightCanvas.width = displayWidth;
            highlightCanvas.height = totalHeight;
            highlightCanvas.style.width = `${displayWidth}px`;
            highlightCanvas.style.height = `${totalHeight}px`;
            displayScaleX = displayWidth / newWidth;
            clearHighlight();
            recomputePixelData();
            console.log("Image loaded:", newWidth, "x", newHeight);
        };
        img.onerror = () => {
            URL.revokeObjectURL(objectURL);
        };
        img.src = objectURL;
    });

    playBtn.addEventListener("click", async () => {
        if (!pixelData) {
            alert("Load an image first!");
            return;
        }
        if (audioCtx && audioCtx.state !== "closed") {
            console.log("Already playing");
            return;
        }

        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        await audioCtx.resume();
        await audioCtx.audioWorklet.addModule("rgb_full_worklet.js");

        workletNode = new AudioWorkletNode(audioCtx, "rgb-full-synth");
        workletNode.port.onmessage = (event) => {
            if (event.data.type === "column") {
                drawHighlight(event.data.column);
            }
        };
        await ensureReverbNodes();
        updateReverbMix();
        clearHighlight();

        durationPerColumn = parseFloat(speedControl.value);
        detuneAmount = parseFloat(detuneControl.value) / 100;
        stereoWidth = parseFloat(stereoControl.value) / 100;
        const parsedBase = parseFloat(baseFreqControl.value);
        if (Number.isFinite(parsedBase)) {
            baseFrequency = parsedBase;
        }
        const parsedBrightness = parseFloat(brightnessControl.value);
        if (Number.isFinite(parsedBrightness)) {
            brightnessAmount = parsedBrightness;
        }
        attackRatio = getSliderPercentValue(attackControl);
        decayRatio = getSliderPercentValue(decayControl);
        recalcEnvelopeTimes();
        harmonicCount = parseInt(harmonicsControl.value, 10) || 100;
        harmonicMode = harmonicModeSelect.value || 'all';
        const parsedOctave = parseInt(octaveSelect.value, 10);
        if (Number.isFinite(parsedOctave)) {
            baseOctave = parsedOctave;
        }
        const parsedPhase = parseFloat(phaseControl.value);
        phaseAmount = Number.isFinite(parsedPhase) ? parsedPhase / 100 : phaseAmount;
        reverbMix = Math.max(0, Math.min(1, parseFloat(reverbControl.value) / 100 || 0));
        updateSpeedDisplay();
        updateDetuneDisplay();
        updateStereoDisplay();
        updateBaseFreqDisplay();
        updateBrightnessDisplay();
        updateAttackDisplay();
        updateDecayDisplay();
        updateHarmonicsDisplay();
        updatePhaseDisplay();
        updateReverbDisplay();

        recomputePixelData();

        {
            const tonalNotes = getSelectedTonalSemitones();
            workletNode.port.postMessage({
                type: "config",
                baseFreq: baseFrequency,
                durationPerColumn,
                detuneAmount,
                stereoWidth,
                attackTime,
                decayTime,
                harmonicCount,
                harmonicMode,
                baseOctave,
                tonalNotes,
                phaseAmount,
                reverbMix,
                sampleRate: audioCtx.sampleRate,
                pixelData
            });
        }

        console.log("Loop playback started");
    });

    stopBtn.addEventListener("click", () => {
        if (audioCtx) {
            teardownReverbNodes();
            audioCtx.close();
            audioCtx = null;
            workletNode = null;
            clearHighlight();
            console.log("Playback stopped");
        }
    });
</script>
</body>
</html>
